package com.nikhilsaraf.distributed_primes.android;

import java.util.LinkedHashSet;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Logger;

import android.app.Activity;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Handler;
import android.view.MotionEvent;
import android.view.View;
import android.widget.Button;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TableRow.LayoutParams;
import android.widget.TextView;

import com.nikhilsaraf.distributed_primes.android.util.SystemUiHider;

/**
 * An example full-screen activity that shows and hides the system UI (i.e.
 * status bar and navigation/system bar) with user interaction.
 *
 * @see SystemUiHider
 */
public class PrimeWorkerMain extends Activity implements PrimeGeneratorDelegate {
	private static final Logger logger = Logger.getLogger(PrimeWorkerMain.class.getSimpleName());
    /**
     * Whether or not the system UI should be auto-hidden after
     * {@link #AUTO_HIDE_DELAY_MILLIS} milliseconds.
     */
    private static final boolean AUTO_HIDE = true;

    /**
     * If {@link #AUTO_HIDE} is set, the number of milliseconds to wait after
     * user interaction before hiding the system UI.
     */
    private static final int AUTO_HIDE_DELAY_MILLIS = 3000;

    /**
     * If set, will toggle the system UI visibility upon interaction. Otherwise,
     * will show the system UI visibility upon interaction.
     */
    private static final boolean TOGGLE_ON_CLICK = true;

    /**
     * The flags to pass to {@link SystemUiHider#getInstance}.
     */
    private static final int HIDER_FLAGS = SystemUiHider.FLAG_HIDE_NAVIGATION;

    /**
     * The instance of the {@link SystemUiHider} for this activity.
     */
    private SystemUiHider mSystemUiHider;
    
    private AbstractPrimeGenerator primeGenerator;
    private TableLayout tableView;
    private Button buttonFindFirstNPrimes;
    private Button buttonFindNextPrime;
    
    private LinkedHashSet<Long> uiVisiblePrimes;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_prime_worker_main);

        /* While it is more computationally efficient to use the sieve, it is more taxing on memory.
         * Also, the sieve needs us to define the maximum number to check for primes up front (because we cannot
         * go up to infinite). This is quite limiting when you consider the limited memory on a mobile device,
         * the variation in hardware etc. Not to mention the extra work needed to be done when you find that
         * maximum prime.
         * 
         * For that reason, I decided to not use the sieve, but use a modified version of the divide till sqrt algorithm.
         * From the perspective and goal of this app, this allows us a few things that outweigh the alternative option:
         * 1. minimal state data needed to be maintain to persist data (and also transfer knowledge in the case of distributed case)
         * 2. minimal memory overhead
         * Disadvantage: Computationally slower
         * 
         * Also, I was running into memory limits on the simulator so had to decide against the sieve after I had implemented it.
         *  
         */
        this.uiVisiblePrimes = new LinkedHashSet<Long>(128);
        
//        // once loaded content view, we want to initiate sieve
//        this.primeGenerator = new SievePrimeGenerator();
        this.primeGenerator = new DividingPrimeGenerator();
        
        tableView = (TableLayout) findViewById(R.id.tableView);
        buttonFindFirstNPrimes = (Button) findViewById(R.id.button_find_first_n_primes);
        buttonFindNextPrime = (Button) findViewById(R.id.button_find_next_prime);
        // TODO implement cancel button
        
        // add click listeners for the buttons
        buttonFindFirstNPrimes.setOnClickListener(findFirstNPrimesClickListener);
        buttonFindNextPrime.setOnClickListener(findNextPrimeClickListener);
        
        resetTableView();
        
        /* ************************************************************************************ */
        /* ************* CODE TO PERFORM AUTO-HIDING OF SCREEN (Autogenerated) **************** */
        /* ************************************************************************************ */
        
        // Set up an instance of SystemUiHider to control the system UI for
        // this activity.
        mSystemUiHider = SystemUiHider.getInstance(this, tableView, HIDER_FLAGS);
        mSystemUiHider.setup();

        // Set up the user interaction to manually show or hide the system UI.
        tableView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                if (TOGGLE_ON_CLICK) {
                    mSystemUiHider.toggle();
                } else {
                    mSystemUiHider.show();
                }
            }
        });

        // Upon interacting with UI controls, delay any scheduled hide()
        // operations to prevent the jarring behavior of controls going away
        // while interacting with the UI.
        buttonFindFirstNPrimes.setOnTouchListener(mDelayHideTouchListener);
        buttonFindNextPrime.setOnTouchListener(mDelayHideTouchListener);

        /* ************************************************************************************ */
        /* ************* / CODE TO PERFORM AUTO-HIDING OF SCREEN (Autogenerated) ************** */
        /* ************************************************************************************ */
    }
    
    @Override
    public void onReceivePrime(Long prime) {
    	if (!this.uiVisiblePrimes.contains(prime)) {
    		logger.info("Received prime from prime generator thread: " + prime + " (was added to UI)");
    		
    		final int number = this.uiVisiblePrimes.size() + 1;	// +1 because we are adding it after this
    		this.uiVisiblePrimes.add(prime);
    		
    		// update UI with prime
    		final TableRow tr = new TableRow(this);
    		final LayoutParams lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
    		tr.setLayoutParams(lp);

    		// SR. No
    		final TextView textViewNumber = new TextView(this);
    		textViewNumber.setLayoutParams(lp);
    		textViewNumber.setBackgroundColor(Color.WHITE);
    		textViewNumber.setText(String.valueOf(number) + ".");
    		tr.addView(textViewNumber);
    		
    		// prime
    		final TextView textViewPrime = new TextView(this);
    		textViewPrime.setLayoutParams(lp);
    		textViewPrime.setBackgroundColor(Color.WHITE);
    		textViewPrime.setText(String.valueOf(prime));
    		tr.addView(textViewPrime);
    		
    		insertIntoTableView(tr);
    	} else {
    		logger.info("Received prime from prime generator thread: " + prime + " (was NOT added to UI because it existed)");
    	}
    }
    
    private void cancelGeneratingPrimes() {
    	primeGenerator.hardCancel();
    }

	private void insertIntoTableView(final TableRow tr) {
		// add to top leaving header
		synchronized (tableView) {
			tableView.addView(tr, 1, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
		}
	}
    
    /* ************************************************************************************ */
    /* ************************ CLICK LISTENERS FOR THE BUTTONS *************************** */
    /* ************************************************************************************ */
    
    /**
     * ClickListener for findFirstNPrimes button
     */
    View.OnClickListener findFirstNPrimesClickListener = new View.OnClickListener() {
		@Override
		public void onClick(View v) {
			// do only if not already running
			if (primeGenerator.isRunning()) {
				alertGeneratorRunning();
			} else {
				final long numberOfPrimesToFind = 10;	// TODO get from input
				
				// if input succeeded
				primeGenerator.setIsRunning();
				
				// we want to start from scratch 
				clearUITable();
				findPrimes(0, numberOfPrimesToFind);
			}
		}
	};
	
	private void clearUITable() {
		uiVisiblePrimes.clear();
		resetTableView();
	}

	private void resetTableView() {
		synchronized (tableView) {
			tableView.removeAllViews();
			
			// update UI with prime
			final TableRow tr = new TableRow(this);
			final LayoutParams lp = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT);
			tr.setLayoutParams(lp);
			
			final TextView textViewNumber = new TextView(this);
			textViewNumber.setLayoutParams(lp);
			textViewNumber.setBackgroundColor(Color.WHITE);
			textViewNumber.setText("N value");
			tr.addView(textViewNumber);
			
			// prime
			final TextView textViewPrime = new TextView(this);
			textViewPrime.setLayoutParams(lp);
			textViewPrime.setBackgroundColor(Color.WHITE);
			textViewPrime.setText("Nth Prime Number");
			tr.addView(textViewPrime);
			
			// insert at top
			tableView.addView(tr, 0, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.WRAP_CONTENT));
		}
	}
	
    /**
     * ClickListener for findNextPrime button
     */
    View.OnClickListener findNextPrimeClickListener = new View.OnClickListener() {
		@Override
		public void onClick(View v) {
			// only add if not already running
			if (primeGenerator.isRunning()) {
				alertGeneratorRunning();
			} else {
				primeGenerator.setIsRunning();
				// find 1 more prime
				findPrimes(uiVisiblePrimes.size(), uiVisiblePrimes.size() + 1);
			}
		}
	};
	
	private void findPrimes(final int startingIndex, final long numberOfPrimesToFind) {
		for (int i = startingIndex; i < numberOfPrimesToFind && i < primeGenerator.getPrimesFound().size(); i++) {
			onReceivePrime(primeGenerator.getPrimesFound().get(i));
		}
		
		if (numberOfPrimesToFind > primeGenerator.getPrimesFound().size()) {
			enqueuePrimeGeneration(numberOfPrimesToFind - primeGenerator.getPrimesFound().size());
		} else {
			// very important, because the job in the queue will not mark it complete as it will never be enqueued
			primeGenerator.markQueueEmpty();
		}
	}
	
	private void enqueuePrimeGeneration(final long N) {
		// submit N jobs
		AsyncTask<Object, Object, Object> task = new AsyncTask<Object, Object, Object>() {
			@Override
			protected Object doInBackground(Object... params) {
				for (int i = 0; i < N; i++) {
					logger.info("Generating a new prime in Executor Service thread");
					primeGenerator.getNextPrime();
				}
				return null;
			}
			
			@Override
		    protected void onPostExecute(Object result) {
		        super.onPostExecute(result);
		        for (long i = primeGenerator.getPrimesFound().size() - N; i < primeGenerator.getPrimesFound().size(); i++) {
		        	onReceivePrime(primeGenerator.getPrimesFound().get((int) i));
		        }
		        primeGenerator.markQueueEmpty();
		    }
		};
		
		task.execute(new Object[]{});
	}

	private void alertGeneratorRunning() {
		logger.info("showed alert because the prime generator is running and we cannot start a new generating action");
		// TODO - need to give a popup saying taht ew are already running and suggest the option of canceling the run from the top
		// buttons
	}
    
    /* ************************************************************************************ */
    /* *********************** / TOUCH LISTENERS FOR THE BUTTONS ************************** */
    /* ************************************************************************************ */

    @Override
    protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);

        // Trigger the initial hide() shortly after the activity has been
        // created, to briefly hint to the user that UI controls
        // are available.
        delayedHide(100);
    }

    /**
     * Touch listener to use for in-layout UI controls to delay hiding the
     * system UI. This is to prevent the jarring behavior of controls going away
     * while interacting with activity UI.
     */
    View.OnTouchListener mDelayHideTouchListener = new View.OnTouchListener() {
        @Override
        public boolean onTouch(View view, MotionEvent motionEvent) {
        	if (AUTO_HIDE) {
                delayedHide(AUTO_HIDE_DELAY_MILLIS);
            }
            return false;
        }
    };

    Handler mHideHandler = new Handler();
    Runnable mHideRunnable = new Runnable() {
        @Override
        public void run() {
            mSystemUiHider.hide();
        }
    };

    /**
     * Schedules a call to hide() in [delay] milliseconds, canceling any
     * previously scheduled calls.
     */
    private void delayedHide(int delayMillis) {
        mHideHandler.removeCallbacks(mHideRunnable);
        mHideHandler.postDelayed(mHideRunnable, delayMillis);
    }
}
